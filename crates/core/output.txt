use {
    crate::cards::card::Card,
    itertools::Itertools,
    rand::seq::SliceRandom,
    serde::{Deserialize, Serialize},
};

/// Struct for Deck that takes the Card Trait and holds a vector of cards
#[derive(Debug, Default, Serialize, Deserialize, Clone)]
pub struct Deck<T: Card> {
    cards: Vec<T>,
}

impl<T: Card> Deck<T> {
    /// Creates an empty deck
    pub fn new() -> Self {
        Self { cards: Vec::new() }
    }
    /// shuffle the deck
    #[inline]
    pub fn shuffle(&mut self) {
        let mut rng = rand::thread_rng();
        self.cards.shuffle(&mut rng);
    }
    /// Tries to remove the `card` given the index panics if the index
    #[inline]
    pub fn draw_index(&mut self, index: usize) -> T {
        self.cards.remove(index)
    }
    /// returns an option to an card
    #[inline]
    pub fn draw_card(&mut self) -> Option<T> {
        self.cards.pop()
    }
    /// adds a card to the deck
    #[inline]
    pub fn add_card(&mut self, card: T) {
        self.cards.push(card)
    }
    /// returns the amount of cards left inside deck
    #[inline]
    pub fn deck_size(&self) -> usize {
        self.cards.len()
    }
    /// Checks if the input deck is a permutation of the other deck
    pub fn is_permutation(&self, other: &Deck<T>) -> bool {
        let perm = self.cards.iter().counts() == other.cards.iter().counts();
        let different = self.cards != other.cards;
        perm && different
    }
    /// returns a copy of the underlying deck   
    #[inline]
    pub fn get_cards(&self) -> Vec<T> {
        self.cards.clone()
    }

    #[inline]
    pub fn extend(&mut self, deck: Deck<T>) {
        self.cards.extend(deck.cards)
    }
}
pub mod deck;
pub mod green_deck;
pub mod red_deck;
use crate::{cards::red_card::RedCard, deck::deck::Deck};
/// Alias RedDeck
pub type RedDeck = Deck<RedCard>;
use crate::{cards::green_card::GreenCard, deck::deck::Deck};
/// Alias GreenDeck
pub type GreenDeck = Deck<GreenCard>;
use {
    super::card::{BaseCard, Card, CardId},
    serde::{Deserialize, Serialize},
    std::fmt,
};

#[derive(Debug, Serialize, Deserialize, Clone, PartialEq, Eq, Hash)]
pub struct GreenCard(BaseCard);

impl GreenCard {
    pub fn new(
        id: impl Into<CardId>,
        name: impl Into<String>,
        description: impl Into<String>,
    ) -> Self {
        Self(BaseCard::new(id, name, description))
    }

    #[inline]
    pub fn base(&self) -> &BaseCard {
        &self.0
    }
}

impl Card for GreenCard {
    #[inline]
    fn id(&self) -> CardId {
        self.0.id()
    }

    #[inline]
    fn name(&self) -> &str {
        self.0.name()
    }

    #[inline]
    fn description(&self) -> &str {
        self.0.description()
    }
}

impl fmt::Display for GreenCard {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        writeln!(
            f,
            "Green card: (\n name {}\n text {}\n id {} )",
            self.name(),
            self.description(),
            self.id().value()
        )
    }
}

impl From<BaseCard> for GreenCard {
    #[inline]
    fn from(base: BaseCard) -> Self {
        Self(base)
    }
}
pub mod card;
pub mod green_card;
pub mod red_card;
use {
    super::card::{BaseCard, Card, CardId},
    serde::{Deserialize, Serialize},
    std::fmt,
};

#[derive(Debug, Serialize, Deserialize, Clone, PartialEq, Eq, Hash)]
pub struct RedCard(BaseCard);

impl RedCard {
    pub fn new(
        id: impl Into<CardId>,
        name: impl Into<String>,
        description: impl Into<String>,
    ) -> Self {
        Self(BaseCard::new(id, name, description))
    }

    #[inline]
    pub fn base(&self) -> &BaseCard {
        &self.0
    }
}

impl Card for RedCard {
    #[inline]
    fn id(&self) -> CardId {
        self.0.id()
    }

    #[inline]
    fn name(&self) -> &str {
        self.0.name()
    }

    #[inline]
    fn description(&self) -> &str {
        self.0.description()
    }
}

impl fmt::Display for RedCard {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        writeln!(
            f,
            "Red card: (\n name {}\n text {}\n id {} )",
            self.name(),
            self.description(),
            self.id().value()
        )
    }
}

impl From<BaseCard> for RedCard {
    #[inline]
    fn from(base: BaseCard) -> Self {
        Self(base)
    }
}
use serde::{Deserialize, Serialize};
use std::{fmt::Debug, hash::Hash};

///Identifier for any card variant.
#[derive(Debug, Serialize, Deserialize, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct CardId(usize);

impl CardId {
    ///Create a new CardId
    #[inline]
    pub fn new(id: usize) -> Self {
        Self(id)
    }

    /// Retrieve the inner value
    #[inline]
    pub fn value(self) -> usize {
        self.0
    }
}

impl From<usize> for CardId {
    #[inline]
    fn from(id: usize) -> Self {
        CardId::new(id)
    }
}

impl From<CardId> for usize {
    #[inline]
    fn from(id: CardId) -> Self {
        id.value()
    }
}

/// Base data shared across concrete card variants.
#[derive(Debug, Serialize, Deserialize, Clone, PartialEq, Eq, Hash)]
pub struct BaseCard {
    id: CardId,
    name: String,
    description: String,
}

impl BaseCard {
    pub fn new(
        id: impl Into<CardId>,
        name: impl Into<String>,
        description: impl Into<String>,
    ) -> Self {
        Self {
            id: id.into(),
            name: name.into(),
            description: description.into(),
        }
    }

    #[inline]
    pub fn id(&self) -> CardId {
        self.id
    }

    #[inline]
    pub fn name(&self) -> &str {
        &self.name
    }

    #[inline]
    pub fn description(&self) -> &str {
        &self.description
    }
}
use super::player::{PlayerHand, PlayerId};

pub struct BasePlayer {
    pub id: PlayerId,
    pub hand: PlayerHand,
    pub score: usize,
}

impl BasePlayer {
    pub fn new(id: PlayerId) -> Self {
        Self {
            id,
            hand: PlayerHand::new(),
            score: 0,
        }
    }
}
use {crate::cards::red_card::RedCard, std::fmt};

#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, PartialOrd)]
pub struct PlayerId(pub usize);

impl fmt::Display for PlayerId {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(f, "PlayerID: {}", self.0)
    }
}

#[derive(Debug, Clone)]
pub struct PlayerHand {
    cards: Vec<RedCard>,
}

impl PlayerHand {
    #[inline]
    pub fn new() -> Self {
        Self { cards: Vec::new() }
    }

    #[inline]
    pub fn add_card(&mut self, card: RedCard) {
        self.cards.push(card);
    }

    #[inline]
    pub fn remove_card(&mut self, index: usize) -> Option<RedCard> {
        if index < self.cards.len() {
            Some(self.cards.remove(index))
        } else {
            None
        }
    }

    #[inline]
    pub fn get_cards(&self) -> &[RedCard] {
        &self.cards
    }

    #[inline]
    pub fn len(&self) -> usize {
        self.cards.len()
    }
}
pub mod base_player;
pub mod player;
pub mod message;
use crate::cards::{green_card::GreenCard, red_card::RedCard};

pub use serde::{Deserialize, Serialize};

#[derive(Serialize, Deserialize, Debug, Clone, PartialEq)]
pub enum GameMessage {
    AssignId(usize),
    DealRedCard(RedCard),
    DealGreenCard(GreenCard),
    RequestRedCardChoice(GreenCard),
    RequestJudgeChoice(Vec<RedCard>, GreenCard),
    RedCardPlayed(usize, RedCard),
    JudgeVoted(usize),
    WinnerAnnouncement(usize, GreenCard),
    CurrentScore(usize),
    MaxScore(usize),
    GameEnd,
}
pub mod cards;
pub mod deck;
pub mod player;
pub mod protocol;
pub use {
    cards::{green_card::GreenCard, red_card::RedCard},
    deck::{green_deck::GreenDeck, red_deck::RedDeck},
    player::player::PlayerId,
};
